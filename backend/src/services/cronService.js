const cron = require('node-cron');
const { Order } = require('../models/Order');
const { Profile } = require('../models/Profile');
const { User } = require('../models/User');
const whatsappService = require('./whatsappService');
const { sequelize } = require('../config/database');
const fs = require('fs').promises;
const path = require('path');

class CronService {
  constructor() {
    this.jobs = new Map();
    this.isRunning = false;
    this.lastExecution = new Map();
    this.executionStats = new Map();
    this.timezone = process.env.CRON_TIMEZONE || 'America/Guayaquil';
  }

  // ===== CONFIGURACI√ìN DE TAREAS PROGRAMADAS =====
  setupCronJobs() {
    try {
      console.log('‚è∞ Configurando tareas programadas...');
      console.log(`üåç Zona horaria: ${this.timezone}`);
      
      // Verificar √≥rdenes que vencen en 3 d√≠as (ejecutar cada d√≠a a las 9:00 AM)
      this.scheduleRenewalReminders();
      
      // Verificar perfiles expirados (ejecutar cada hora)
      this.scheduleProfileExpirationCheck();
      
      // Limpiar archivos temporales (ejecutar cada d√≠a a las 2:00 AM)
      this.scheduleCleanupTasks();
      
      // Verificar estado de WhatsApp (ejecutar cada 30 minutos)
      this.scheduleWhatsAppHealthCheck();
      
      // Backup de base de datos (ejecutar cada domingo a las 3:00 AM)
      this.scheduleDatabaseBackup();
      
      // Verificaci√≥n de salud del sistema (ejecutar cada 15 minutos)
      this.scheduleSystemHealthCheck();
      
      // Limpieza de logs antiguos (ejecutar cada d√≠a a las 1:00 AM)
      this.scheduleLogCleanup();
      
      console.log('‚úÖ Tareas programadas configuradas exitosamente');
      console.log(`üìä Total de tareas: ${this.jobs.size}`);
      
      // Mostrar resumen de tareas
      this.showJobSummary();
      
    } catch (error) {
      console.error('‚ùå Error al configurar tareas programadas:', error);
      throw error;
    }
  }

  // ===== PROGRAMACI√ìN DE TAREAS =====

  scheduleRenewalReminders() {
    const job = cron.schedule('0 9 * * *', async () => {
      await this.executeJob('renewalReminders', this.checkExpiringOrders.bind(this));
    }, {
      scheduled: true,
      timezone: this.timezone
    });

    this.jobs.set('renewalReminders', job);
    console.log('‚úÖ Tarea de recordatorios de renovaci√≥n programada (9:00 AM diario)');
  }

  scheduleProfileExpirationCheck() {
    const job = cron.schedule('0 * * * *', async () => {
      await this.executeJob('profileExpirationCheck', this.checkExpiredProfiles.bind(this));
    }, {
      scheduled: true,
      timezone: this.timezone
    });

    this.jobs.set('profileExpirationCheck', job);
    console.log('‚úÖ Tarea de verificaci√≥n de perfiles expirados programada (cada hora)');
  }

  scheduleCleanupTasks() {
    const job = cron.schedule('0 2 * * *', async () => {
      await this.executeJob('cleanupTasks', this.cleanupTempFiles.bind(this));
    }, {
      scheduled: true,
      timezone: this.timezone
    });

    this.jobs.set('cleanupTasks', job);
    console.log('‚úÖ Tarea de limpieza programada (2:00 AM diario)');
  }

  scheduleWhatsAppHealthCheck() {
    const job = cron.schedule('*/30 * * * *', async () => {
      await this.executeJob('whatsAppHealthCheck', this.checkWhatsAppHealth.bind(this));
    }, {
      scheduled: true,
      timezone: this.timezone
    });

    this.jobs.set('whatsAppHealthCheck', job);
    console.log('‚úÖ Tarea de verificaci√≥n de salud de WhatsApp programada (cada 30 minutos)');
  }

  scheduleDatabaseBackup() {
    const job = cron.schedule('0 3 * * 0', async () => {
      await this.executeJob('databaseBackup', this.createDatabaseBackup.bind(this));
    }, {
      scheduled: true,
      timezone: this.timezone
    });

    this.jobs.set('databaseBackup', job);
    console.log('‚úÖ Tarea de backup de base de datos programada (3:00 AM domingos)');
  }

  scheduleSystemHealthCheck() {
    const job = cron.schedule('*/15 * * * *', async () => {
      await this.executeJob('systemHealthCheck', this.checkSystemHealth.bind(this));
    }, {
      scheduled: true,
      timezone: this.timezone
    });

    this.jobs.set('systemHealthCheck', job);
    console.log('‚úÖ Tarea de verificaci√≥n de salud del sistema programada (cada 15 minutos)');
  }

  scheduleLogCleanup() {
    const job = cron.schedule('0 1 * * *', async () => {
      await this.executeJob('logCleanup', this.cleanupOldLogs.bind(this));
    }, {
      scheduled: true,
      timezone: this.timezone
    });

    this.jobs.set('logCleanup', job);
    console.log('‚úÖ Tarea de limpieza de logs programada (1:00 AM diario)');
  }

  // ===== EJECUCI√ìN DE TAREAS CON MANEJO DE ERRORES =====

  async executeJob(jobName, jobFunction) {
    if (this.isRunning) {
      console.log(`‚è≥ Tarea ${jobName} ya est√° ejecut√°ndose, saltando...`);
      return;
    }

    const startTime = Date.now();
    this.isRunning = true;
    this.lastExecution.set(jobName, new Date());

    try {
      console.log(`üïò Ejecutando tarea: ${jobName}`);
      await jobFunction();
      
      const duration = Date.now() - startTime;
      this.updateExecutionStats(jobName, true, duration);
      
      console.log(`‚úÖ Tarea ${jobName} completada exitosamente (${duration}ms)`);
      
    } catch (error) {
      const duration = Date.now() - startTime;
      this.updateExecutionStats(jobName, false, duration);
      
      console.error(`‚ùå Error en tarea ${jobName}:`, error.message);
      console.error('Stack trace:', error.stack);
      
      // Notificar error cr√≠tico
      await this.notifyJobError(jobName, error);
      
    } finally {
      this.isRunning = false;
    }
  }

  // ===== IMPLEMENTACI√ìN DE TAREAS =====

  async checkExpiringOrders() {
    try {
      const expiringOrders = await Order.findExpiringOrders(3);
      
      if (expiringOrders.length === 0) {
        console.log('üìã No hay √≥rdenes pr√≥ximas a vencer');
        return;
      }

      console.log(`üìã Encontradas ${expiringOrders.length} √≥rdenes pr√≥ximas a vencer`);
      
      for (const order of expiringOrders) {
        try {
          const user = await User.findByPk(order.user_id);
          if (user && whatsappService.isConnected) {
            await whatsappService.sendRenewalReminder(user.whatsapp, order);
            console.log(`üì± Recordatorio enviado a ${user.email} para orden ${order.id}`);
          }
        } catch (userError) {
          console.error(`‚ùå Error al enviar recordatorio para orden ${order.id}:`, userError.message);
        }
      }
      
    } catch (error) {
      console.error('‚ùå Error al verificar √≥rdenes pr√≥ximas a vencer:', error);
      throw error;
    }
  }

  async checkExpiredProfiles() {
    try {
      const expiredProfiles = await Profile.findAll({
        where: {
          estado: 'asignado',
          fecha_expiracion: {
            [sequelize.Op.lt]: new Date()
          }
        }
      });

      if (expiredProfiles.length === 0) {
        console.log('üìã No hay perfiles expirados');
        return;
      }

      console.log(`üìã Encontrados ${expiredProfiles.length} perfiles expirados`);
      
      for (const profile of expiredProfiles) {
        try {
          profile.estado = 'libre';
          profile.user_id_asignado = null;
          profile.order_id_asignado = null;
          profile.fecha_asignacion = null;
          profile.fecha_expiracion = null;
          await profile.save();
          
          console.log(`‚úÖ Perfil ${profile.id} liberado por expiraci√≥n`);
        } catch (profileError) {
          console.error(`‚ùå Error al liberar perfil ${profile.id}:`, profileError.message);
        }
      }
      
    } catch (error) {
      console.error('‚ùå Error al verificar perfiles expirados:', error);
      throw error;
    }
  }

  async cleanupTempFiles() {
    try {
      const tempDir = path.join(__dirname, '../../uploads/temp');
      
      try {
        const files = await fs.readdir(tempDir);
        let deletedCount = 0;
        
        for (const file of files) {
          const filePath = path.join(tempDir, file);
          const stats = await fs.stat(filePath);
          const fileAge = Date.now() - stats.mtime.getTime();
          
          // Eliminar archivos m√°s antiguos de 24 horas
          if (fileAge > 24 * 60 * 60 * 1000) {
            await fs.unlink(filePath);
            deletedCount++;
          }
        }
        
        console.log(`üóëÔ∏è  Limpieza completada: ${deletedCount} archivos temporales eliminados`);
        
      } catch (dirError) {
        if (dirError.code === 'ENOENT') {
          console.log('üìÅ Directorio de archivos temporales no existe, creando...');
          await fs.mkdir(tempDir, { recursive: true });
        } else {
          throw dirError;
        }
      }
      
    } catch (error) {
      console.error('‚ùå Error en limpieza de archivos temporales:', error);
      throw error;
    }
  }

  async checkWhatsAppHealth() {
    try {
      if (whatsappService.isConnected) {
        console.log('‚úÖ WhatsApp est√° conectado');
      } else {
        console.log('‚ö†Ô∏è  WhatsApp no est√° conectado, intentando reconectar...');
        try {
          await whatsappService.initialize();
          console.log('‚úÖ WhatsApp reconectado exitosamente');
        } catch (reconnectError) {
          console.error('‚ùå No se pudo reconectar WhatsApp:', reconnectError.message);
        }
      }
    } catch (error) {
      console.error('‚ùå Error al verificar salud de WhatsApp:', error);
      throw error;
    }
  }

  async createDatabaseBackup() {
    try {
      const backupDir = path.join(__dirname, '../../backups');
      await fs.mkdir(backupDir, { recursive: true });
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupFile = path.join(backupDir, `backup-${timestamp}.sql`);
      
      // Crear backup usando pg_dump (requiere que est√© instalado)
      const { exec } = require('child_process');
      const { promisify } = require('util');
      const execAsync = promisify(exec);
      
      const dbConfig = {
        host: process.env.DB_HOST || 'localhost',
        port: process.env.DB_PORT || 5432,
        database: process.env.DB_NAME || 'streaming_system',
        username: process.env.DB_USER || 'postgres'
      };
      
      const pgDumpCommand = `pg_dump -h ${dbConfig.host} -p ${dbConfig.port} -U ${dbConfig.username} -d ${dbConfig.database} > ${backupFile}`;
      
      await execAsync(pgDumpCommand, {
        env: { ...process.env, PGPASSWORD: process.env.DB_PASSWORD }
      });
      
      console.log(`üíæ Backup de base de datos creado: ${backupFile}`);
      
      // Limpiar backups antiguos (mantener solo los √∫ltimos 7)
      await this.cleanupOldBackups(backupDir, 7);
      
    } catch (error) {
      console.error('‚ùå Error al crear backup de base de datos:', error);
      // No lanzar error para no interrumpir otras tareas
    }
  }

  async checkSystemHealth() {
    try {
      const health = {
        timestamp: new Date().toISOString(),
        database: 'unknown',
        whatsapp: 'unknown',
        memory: process.memoryUsage(),
        uptime: process.uptime()
      };

      // Verificar base de datos
      try {
        await sequelize.authenticate();
        health.database = 'connected';
      } catch (dbError) {
        health.database = 'disconnected';
        console.warn('‚ö†Ô∏è  Base de datos desconectada durante health check');
      }

      // Verificar WhatsApp
      health.whatsapp = whatsappService.isConnected ? 'connected' : 'disconnected';

      // Log de salud del sistema
      if (health.database === 'disconnected' || health.whatsapp === 'disconnected') {
        console.warn('‚ö†Ô∏è  Sistema en estado degradado:', health);
      } else {
        console.log('‚úÖ Sistema saludable:', health);
      }

    } catch (error) {
      console.error('‚ùå Error en health check del sistema:', error);
      // No lanzar error para no interrumpir otras tareas
    }
  }

  async cleanupOldLogs() {
    try {
      const logDir = path.join(__dirname, '../../logs');
      
      try {
        const files = await fs.readdir(logDir);
        let deletedCount = 0;
        
        for (const file of files) {
          if (file.endsWith('.log')) {
            const filePath = path.join(logDir, file);
            const stats = await fs.stat(filePath);
            const fileAge = Date.now() - stats.mtime.getTime();
            
            // Eliminar logs m√°s antiguos de 30 d√≠as
            if (fileAge > 30 * 24 * 60 * 60 * 1000) {
              await fs.unlink(filePath);
              deletedCount++;
            }
          }
        }
        
        console.log(`üóëÔ∏è  Limpieza de logs completada: ${deletedCount} archivos eliminados`);
        
      } catch (dirError) {
        if (dirError.code === 'ENOENT') {
          console.log('üìÅ Directorio de logs no existe');
        } else {
          throw dirError;
        }
      }
      
    } catch (error) {
      console.error('‚ùå Error en limpieza de logs:', error);
      // No lanzar error para no interrumpir otras tareas
    }
  }

  // ===== FUNCIONES DE UTILIDAD =====

  async cleanupOldBackups(backupDir, keepCount) {
    try {
      const files = await fs.readdir(backupDir);
      const backupFiles = files
        .filter(file => file.startsWith('backup-') && file.endsWith('.sql'))
        .map(file => ({
          name: file,
          path: path.join(backupDir, file),
          mtime: fs.stat(path.join(backupDir, file)).then(stats => stats.mtime)
        }));

      if (backupFiles.length <= keepCount) return;

      // Ordenar por fecha de modificaci√≥n (m√°s reciente primero)
      const sortedFiles = await Promise.all(backupFiles);
      sortedFiles.sort((a, b) => b.mtime - a.mtime);

      // Eliminar archivos antiguos
      const filesToDelete = sortedFiles.slice(keepCount);
      for (const file of filesToDelete) {
        await fs.unlink(file.path);
        console.log(`üóëÔ∏è  Backup antiguo eliminado: ${file.name}`);
      }
      
    } catch (error) {
      console.error('‚ùå Error al limpiar backups antiguos:', error);
    }
  }

  updateExecutionStats(jobName, success, duration) {
    if (!this.executionStats.has(jobName)) {
      this.executionStats.set(jobName, {
        totalExecutions: 0,
        successfulExecutions: 0,
        failedExecutions: 0,
        totalDuration: 0,
        averageDuration: 0,
        lastSuccess: null,
        lastFailure: null
      });
    }

    const stats = this.executionStats.get(jobName);
    stats.totalExecutions++;
    stats.totalDuration += duration;
    stats.averageDuration = stats.totalDuration / stats.totalExecutions;

    if (success) {
      stats.successfulExecutions++;
      stats.lastSuccess = new Date();
    } else {
      stats.failedExecutions++;
      stats.lastFailure = new Date();
    }
  }

  async notifyJobError(jobName, error) {
    try {
      // Aqu√≠ podr√≠as implementar notificaciones por email, Slack, etc.
      console.error(`üö® NOTIFICACI√ìN: Error cr√≠tico en tarea ${jobName}:`, error.message);
      
      // Por ahora solo log, pero podr√≠as expandir esto
      if (process.env.NODE_ENV === 'production') {
        // En producci√≥n, podr√≠as enviar notificaci√≥n por email o Slack
        console.error('üö® Error cr√≠tico en producci√≥n - considerar notificaci√≥n externa');
      }
      
    } catch (notifyError) {
      console.error('‚ùå Error al notificar error de tarea:', notifyError);
    }
  }

  showJobSummary() {
    console.log('\nüìä RESUMEN DE TAREAS PROGRAMADAS:');
    console.log('=' .repeat(50));
    
    const jobDetails = [
      { name: 'renewalReminders', description: 'Recordatorios de renovaci√≥n', schedule: '9:00 AM diario' },
      { name: 'profileExpirationCheck', description: 'Verificaci√≥n de perfiles expirados', schedule: 'Cada hora' },
      { name: 'cleanupTasks', description: 'Limpieza de archivos temporales', schedule: '2:00 AM diario' },
      { name: 'whatsAppHealthCheck', description: 'Verificaci√≥n de salud de WhatsApp', schedule: 'Cada 30 minutos' },
      { name: 'databaseBackup', description: 'Backup de base de datos', schedule: '3:00 AM domingos' },
      { name: 'systemHealthCheck', description: 'Verificaci√≥n de salud del sistema', schedule: 'Cada 15 minutos' },
      { name: 'logCleanup', description: 'Limpieza de logs antiguos', schedule: '1:00 AM diario' }
    ];

    jobDetails.forEach(job => {
      console.log(`‚è∞ ${job.name}: ${job.description} (${job.schedule})`);
    });
    
    console.log('=' .repeat(50));
  }

  // ===== CONTROL DE TAREAS =====

  stopAllJobs() {
    console.log('üõë Deteniendo todas las tareas programadas...');
    
    for (const [jobName, job] of this.jobs) {
      try {
        job.stop();
        console.log(`‚úÖ Tarea ${jobName} detenida`);
      } catch (error) {
        console.error(`‚ùå Error al detener tarea ${jobName}:`, error.message);
      }
    }
    
    this.jobs.clear();
    console.log('‚úÖ Todas las tareas han sido detenidas');
  }

  getJobStatus() {
    const status = {};
    
    for (const [jobName, job] of this.jobs) {
      status[jobName] = {
        running: job.running,
        lastExecution: this.lastExecution.get(jobName),
        stats: this.executionStats.get(jobName) || {}
      };
    }
    
    return status;
  }

  // ===== LIMPIEZA AL CERRAR =====
  
  async cleanup() {
    try {
      console.log('üßπ Limpiando servicio de cron...');
      this.stopAllJobs();
      console.log('‚úÖ Servicio de cron limpiado');
    } catch (error) {
      console.error('‚ùå Error al limpiar servicio de cron:', error);
    }
  }
}

// Crear instancia singleton
const cronService = new CronService();

// Manejo de cierre graceful
process.on('SIGTERM', async () => {
  console.log('üõë Recibida se√±al SIGTERM, limpiando cron service...');
  await cronService.cleanup();
});

process.on('SIGINT', async () => {
  console.log('üõë Recibida se√±al SIGINT, limpiando cron service...');
  await cronService.cleanup();
});

module.exports = cronService;
